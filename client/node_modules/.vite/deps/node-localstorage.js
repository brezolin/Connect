import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-DWA4UIM3.js";

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS({
  "node_modules/imurmurhash/imurmurhash.js"(exports, module) {
    (function() {
      var cache;
      function MurmurHash3(key, seed) {
        var m = this instanceof MurmurHash3 ? this : cache;
        m.reset(seed);
        if (typeof key === "string" && key.length > 0) {
          m.hash(key);
        }
        if (m !== this) {
          return m;
        }
      }
      ;
      MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;
        len = key.length;
        this.len += len;
        k1 = this.k1;
        i = 0;
        switch (this.rem) {
          case 0:
            k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0;
            k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        this.rem = len + this.rem & 3;
        len -= this.rem;
        if (len > 0) {
          h1 = this.h1;
          while (1) {
            k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = h1 * 5 + 3864292196 & 4294967295;
            if (i >= len) {
              break;
            }
            k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16;
            top = key.charCodeAt(i++);
            k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          }
          k1 = 0;
          switch (this.rem) {
            case 3:
              k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        this.k1 = k1;
        return this;
      };
      MurmurHash3.prototype.result = function() {
        var k1, h1;
        k1 = this.k1;
        h1 = this.h1;
        if (k1 > 0) {
          k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
          h1 ^= k1;
        }
        h1 ^= this.len;
        h1 ^= h1 >>> 16;
        h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295;
        h1 ^= h1 >>> 16;
        return h1 >>> 0;
      };
      MurmurHash3.prototype.reset = function(seed) {
        this.h1 = typeof seed === "number" ? seed : 0;
        this.rem = this.k1 = this.len = 0;
        return this;
      };
      cache = new MurmurHash3();
      if (typeof module != "undefined") {
        module.exports = MurmurHash3;
      } else {
        this.MurmurHash3 = MurmurHash3;
      }
    })();
  }
});

// node_modules/signal-exit/dist/cjs/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/dist/cjs/signals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signals = void 0;
    exports.signals = [];
    exports.signals.push("SIGHUP", "SIGINT", "SIGTERM");
    if (process.platform !== "win32") {
      exports.signals.push(
        "SIGALRM",
        "SIGABRT",
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      exports.signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
    }
  }
});

// node_modules/signal-exit/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/signal-exit/dist/cjs/index.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unload = exports.load = exports.onExit = exports.signals = void 0;
    var signals_js_1 = require_signals();
    Object.defineProperty(exports, "signals", { enumerable: true, get: function() {
      return signals_js_1.signals;
    } });
    var processOk = (process3) => !!process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
    var kExitEmitter = Symbol.for("signal-exit emitter");
    var global = globalThis;
    var ObjectDefineProperty = Object.defineProperty.bind(Object);
    var Emitter = class {
      constructor() {
        __publicField(this, "emitted", {
          afterExit: false,
          exit: false
        });
        __publicField(this, "listeners", {
          afterExit: [],
          exit: []
        });
        __publicField(this, "count", 0);
        __publicField(this, "id", Math.random());
        if (global[kExitEmitter]) {
          return global[kExitEmitter];
        }
        ObjectDefineProperty(global, kExitEmitter, {
          value: this,
          writable: false,
          enumerable: false,
          configurable: false
        });
      }
      on(ev, fn) {
        this.listeners[ev].push(fn);
      }
      removeListener(ev, fn) {
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        if (i === -1) {
          return;
        }
        if (i === 0 && list.length === 1) {
          list.length = 0;
        } else {
          list.splice(i, 1);
        }
      }
      emit(ev, code, signal) {
        if (this.emitted[ev]) {
          return false;
        }
        this.emitted[ev] = true;
        let ret = false;
        for (const fn of this.listeners[ev]) {
          ret = fn(code, signal) === true || ret;
        }
        if (ev === "exit") {
          ret = this.emit("afterExit", code, signal) || ret;
        }
        return ret;
      }
    };
    var SignalExitBase = class {
    };
    var signalExitWrap = (handler) => {
      return {
        onExit(cb, opts) {
          return handler.onExit(cb, opts);
        },
        load() {
          return handler.load();
        },
        unload() {
          return handler.unload();
        }
      };
    };
    var SignalExitFallback = class extends SignalExitBase {
      onExit() {
        return () => {
        };
      }
      load() {
      }
      unload() {
      }
    };
    var _hupSig, _emitter, _process, _originalProcessEmit, _originalProcessReallyExit, _sigListeners, _loaded, _SignalExit_instances, processReallyExit_fn, processEmit_fn;
    var SignalExit = class extends SignalExitBase {
      constructor(process3) {
        super();
        __privateAdd(this, _SignalExit_instances);
        // "SIGHUP" throws an `ENOSYS` error on Windows,
        // so use a supported signal instead
        /* c8 ignore start */
        __privateAdd(this, _hupSig, process2.platform === "win32" ? "SIGINT" : "SIGHUP");
        /* c8 ignore stop */
        __privateAdd(this, _emitter, new Emitter());
        __privateAdd(this, _process);
        __privateAdd(this, _originalProcessEmit);
        __privateAdd(this, _originalProcessReallyExit);
        __privateAdd(this, _sigListeners, {});
        __privateAdd(this, _loaded, false);
        __privateSet(this, _process, process3);
        __privateSet(this, _sigListeners, {});
        for (const sig of signals_js_1.signals) {
          __privateGet(this, _sigListeners)[sig] = () => {
            const listeners = __privateGet(this, _process).listeners(sig);
            let { count } = __privateGet(this, _emitter);
            const p = process3;
            if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
              count += p.__signal_exit_emitter__.count;
            }
            if (listeners.length === count) {
              this.unload();
              const ret = __privateGet(this, _emitter).emit("exit", null, sig);
              const s = sig === "SIGHUP" ? __privateGet(this, _hupSig) : sig;
              if (!ret)
                process3.kill(process3.pid, s);
            }
          };
        }
        __privateSet(this, _originalProcessReallyExit, process3.reallyExit);
        __privateSet(this, _originalProcessEmit, process3.emit);
      }
      onExit(cb, opts) {
        if (!processOk(__privateGet(this, _process))) {
          return () => {
          };
        }
        if (__privateGet(this, _loaded) === false) {
          this.load();
        }
        const ev = (opts == null ? void 0 : opts.alwaysLast) ? "afterExit" : "exit";
        __privateGet(this, _emitter).on(ev, cb);
        return () => {
          __privateGet(this, _emitter).removeListener(ev, cb);
          if (__privateGet(this, _emitter).listeners["exit"].length === 0 && __privateGet(this, _emitter).listeners["afterExit"].length === 0) {
            this.unload();
          }
        };
      }
      load() {
        if (__privateGet(this, _loaded)) {
          return;
        }
        __privateSet(this, _loaded, true);
        __privateGet(this, _emitter).count += 1;
        for (const sig of signals_js_1.signals) {
          try {
            const fn = __privateGet(this, _sigListeners)[sig];
            if (fn)
              __privateGet(this, _process).on(sig, fn);
          } catch (_) {
          }
        }
        __privateGet(this, _process).emit = (ev, ...a) => {
          return __privateMethod(this, _SignalExit_instances, processEmit_fn).call(this, ev, ...a);
        };
        __privateGet(this, _process).reallyExit = (code) => {
          return __privateMethod(this, _SignalExit_instances, processReallyExit_fn).call(this, code);
        };
      }
      unload() {
        if (!__privateGet(this, _loaded)) {
          return;
        }
        __privateSet(this, _loaded, false);
        signals_js_1.signals.forEach((sig) => {
          const listener = __privateGet(this, _sigListeners)[sig];
          if (!listener) {
            throw new Error("Listener not defined for signal: " + sig);
          }
          try {
            __privateGet(this, _process).removeListener(sig, listener);
          } catch (_) {
          }
        });
        __privateGet(this, _process).emit = __privateGet(this, _originalProcessEmit);
        __privateGet(this, _process).reallyExit = __privateGet(this, _originalProcessReallyExit);
        __privateGet(this, _emitter).count -= 1;
      }
    };
    _hupSig = new WeakMap();
    _emitter = new WeakMap();
    _process = new WeakMap();
    _originalProcessEmit = new WeakMap();
    _originalProcessReallyExit = new WeakMap();
    _sigListeners = new WeakMap();
    _loaded = new WeakMap();
    _SignalExit_instances = new WeakSet();
    processReallyExit_fn = function(code) {
      if (!processOk(__privateGet(this, _process))) {
        return 0;
      }
      __privateGet(this, _process).exitCode = code || 0;
      __privateGet(this, _emitter).emit("exit", __privateGet(this, _process).exitCode, null);
      return __privateGet(this, _originalProcessReallyExit).call(__privateGet(this, _process), __privateGet(this, _process).exitCode);
    };
    processEmit_fn = function(ev, ...args) {
      const og = __privateGet(this, _originalProcessEmit);
      if (ev === "exit" && processOk(__privateGet(this, _process))) {
        if (typeof args[0] === "number") {
          __privateGet(this, _process).exitCode = args[0];
        }
        const ret = og.call(__privateGet(this, _process), ev, ...args);
        __privateGet(this, _emitter).emit("exit", __privateGet(this, _process).exitCode, null);
        return ret;
      } else {
        return og.call(__privateGet(this, _process), ev, ...args);
      }
    };
    var process2 = globalThis.process;
    _a = signalExitWrap(processOk(process2) ? new SignalExit(process2) : new SignalExitFallback()), /**
     * Called when the process is exiting, whether via signal, explicit
     * exit, or running out of stuff to do.
     *
     * If the global process object is not suitable for instrumentation,
     * then this will be a no-op.
     *
     * Returns a function that may be used to unload signal-exit.
     */
    exports.onExit = _a.onExit, /**
     * Load the listeners.  Likely you never need to call this, unless
     * doing a rather deep integration with signal-exit functionality.
     * Mostly exposed for the benefit of testing.
     *
     * @internal
     */
    exports.load = _a.load, /**
     * Unload the listeners.  Likely you never need to call this, unless
     * doing a rather deep integration with signal-exit functionality.
     * Mostly exposed for the benefit of testing.
     *
     * @internal
     */
    exports.unload = _a.unload;
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:worker_threads
var require_worker_threads = __commonJS({
  "browser-external:worker_threads"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "worker_threads" has been externalized for browser compatibility. Cannot access "worker_threads.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/write-file-atomic/lib/index.js
var require_lib = __commonJS({
  "node_modules/write-file-atomic/lib/index.js"(exports, module) {
    "use strict";
    module.exports = writeFile;
    module.exports.sync = writeFileSync;
    module.exports._getTmpname = getTmpname;
    module.exports._cleanupOnExit = cleanupOnExit;
    var fs = require_fs();
    var MurmurHash3 = require_imurmurhash();
    var { onExit } = require_cjs();
    var path = require_path();
    var { promisify } = require_util();
    var activeFiles = {};
    var threadId = function getId() {
      try {
        const workerThreads = require_worker_threads();
        return workerThreads.threadId;
      } catch (e) {
        return 0;
      }
    }();
    var invocations = 0;
    function getTmpname(filename) {
      return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
    }
    function cleanupOnExit(tmpfile) {
      return () => {
        try {
          fs.unlinkSync(typeof tmpfile === "function" ? tmpfile() : tmpfile);
        } catch {
        }
      };
    }
    function serializeActiveFile(absoluteName) {
      return new Promise((resolve) => {
        if (!activeFiles[absoluteName]) {
          activeFiles[absoluteName] = [];
        }
        activeFiles[absoluteName].push(resolve);
        if (activeFiles[absoluteName].length === 1) {
          resolve();
        }
      });
    }
    function isChownErrOk(err) {
      if (err.code === "ENOSYS") {
        return true;
      }
      const nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (err.code === "EINVAL" || err.code === "EPERM") {
          return true;
        }
      }
      return false;
    }
    async function writeFileAsync(filename, data, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      let fd;
      let tmpfile;
      const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile));
      const absoluteName = path.resolve(filename);
      try {
        await serializeActiveFile(absoluteName);
        const truename = await promisify(fs.realpath)(filename).catch(() => filename);
        tmpfile = getTmpname(truename);
        if (!options.mode || !options.chown) {
          const stats = await promisify(fs.stat)(truename).catch(() => {
          });
          if (stats) {
            if (options.mode == null) {
              options.mode = stats.mode;
            }
            if (options.chown == null && process.getuid) {
              options.chown = { uid: stats.uid, gid: stats.gid };
            }
          }
        }
        fd = await promisify(fs.open)(tmpfile, "w", options.mode);
        if (options.tmpfileCreated) {
          await options.tmpfileCreated(tmpfile);
        }
        if (ArrayBuffer.isView(data)) {
          await promisify(fs.write)(fd, data, 0, data.length, 0);
        } else if (data != null) {
          await promisify(fs.write)(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          await promisify(fs.fsync)(fd);
        }
        await promisify(fs.close)(fd);
        fd = null;
        if (options.chown) {
          await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        if (options.mode) {
          await promisify(fs.chmod)(tmpfile, options.mode).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        await promisify(fs.rename)(tmpfile, truename);
      } finally {
        if (fd) {
          await promisify(fs.close)(fd).catch(
            /* istanbul ignore next */
            () => {
            }
          );
        }
        removeOnExitHandler();
        await promisify(fs.unlink)(tmpfile).catch(() => {
        });
        activeFiles[absoluteName].shift();
        if (activeFiles[absoluteName].length > 0) {
          activeFiles[absoluteName][0]();
        } else {
          delete activeFiles[absoluteName];
        }
      }
    }
    async function writeFile(filename, data, options, callback) {
      if (options instanceof Function) {
        callback = options;
        options = {};
      }
      const promise = writeFileAsync(filename, data, options);
      if (callback) {
        try {
          const result = await promise;
          return callback(result);
        } catch (err) {
          return callback(err);
        }
      }
      return promise;
    }
    function writeFileSync(filename, data, options) {
      if (typeof options === "string") {
        options = { encoding: options };
      } else if (!options) {
        options = {};
      }
      try {
        filename = fs.realpathSync(filename);
      } catch (ex) {
      }
      const tmpfile = getTmpname(filename);
      if (!options.mode || !options.chown) {
        try {
          const stats = fs.statSync(filename);
          options = Object.assign({}, options);
          if (!options.mode) {
            options.mode = stats.mode;
          }
          if (!options.chown && process.getuid) {
            options.chown = { uid: stats.uid, gid: stats.gid };
          }
        } catch (ex) {
        }
      }
      let fd;
      const cleanup = cleanupOnExit(tmpfile);
      const removeOnExitHandler = onExit(cleanup);
      let threw = true;
      try {
        fd = fs.openSync(tmpfile, "w", options.mode || 438);
        if (options.tmpfileCreated) {
          options.tmpfileCreated(tmpfile);
        }
        if (ArrayBuffer.isView(data)) {
          fs.writeSync(fd, data, 0, data.length, 0);
        } else if (data != null) {
          fs.writeSync(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          fs.fsyncSync(fd);
        }
        fs.closeSync(fd);
        fd = null;
        if (options.chown) {
          try {
            fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        if (options.mode) {
          try {
            fs.chmodSync(tmpfile, options.mode);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        fs.renameSync(tmpfile, filename);
        threw = false;
      } finally {
        if (fd) {
          try {
            fs.closeSync(fd);
          } catch (ex) {
          }
        }
        removeOnExitHandler();
        if (threw) {
          cleanup();
        }
      }
    }
  }
});

// node_modules/node-localstorage/LocalStorage.js
var require_LocalStorage = __commonJS({
  "node_modules/node-localstorage/LocalStorage.js"(exports) {
    (function() {
      var JSONStorage, KEY_FOR_EMPTY_STRING, LocalStorage, MetaKey, QUOTA_EXCEEDED_ERR, StorageEvent, _emptyDirectory, _escapeKey, _rm, createMap, events, fs, path, writeSync;
      path = require_path();
      fs = require_fs();
      events = require_events();
      writeSync = require_lib().sync;
      KEY_FOR_EMPTY_STRING = "---.EMPTY_STRING.---";
      _emptyDirectory = function(target) {
        var i, len, p, ref, results;
        ref = fs.readdirSync(target);
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          p = ref[i];
          results.push(_rm(path.join(target, p)));
        }
        return results;
      };
      _rm = function(target) {
        if (fs.statSync(target).isDirectory()) {
          _emptyDirectory(target);
          return fs.rmdirSync(target);
        } else {
          return fs.unlinkSync(target);
        }
      };
      _escapeKey = function(key) {
        var newKey;
        if (key === "") {
          newKey = KEY_FOR_EMPTY_STRING;
        } else {
          newKey = `${key}`;
        }
        return newKey;
      };
      QUOTA_EXCEEDED_ERR = class QUOTA_EXCEEDED_ERR extends Error {
        constructor(message = "Unknown error.") {
          super();
          this.message = message;
          if (Error.captureStackTrace != null) {
            Error.captureStackTrace(this, this.constructor);
          }
          this.name = this.constructor.name;
        }
        toString() {
          return `${this.name}: ${this.message}`;
        }
      };
      StorageEvent = class StorageEvent {
        constructor(key1, oldValue1, newValue1, url, storageArea = "localStorage") {
          this.key = key1;
          this.oldValue = oldValue1;
          this.newValue = newValue1;
          this.url = url;
          this.storageArea = storageArea;
        }
      };
      MetaKey = class MetaKey2 {
        // MetaKey contains key and size
        constructor(key1, index1) {
          this.key = key1;
          this.index = index1;
          if (!(this instanceof MetaKey2)) {
            return new MetaKey2(this.key, this.index);
          }
        }
      };
      createMap = function() {
        var Map;
        Map = function() {
        };
        Map.prototype = /* @__PURE__ */ Object.create(null);
        return new Map();
      };
      LocalStorage = (function() {
        var instanceMap;
        class LocalStorage2 extends events.EventEmitter {
          constructor(_location, quota = 5 * 1024 * 1024) {
            var handler;
            super();
            this._location = _location;
            this.quota = quota;
            if (!(this instanceof LocalStorage2)) {
              return new LocalStorage2(this._location, this.quota);
            }
            this._location = path.resolve(this._location);
            if (instanceMap[this._location] != null) {
              return instanceMap[this._location];
            }
            this.length = 0;
            this._bytesInUse = 0;
            this._keys = [];
            this._metaKeyMap = createMap();
            this._eventUrl = "pid:" + process.pid;
            this._init();
            this._QUOTA_EXCEEDED_ERR = QUOTA_EXCEEDED_ERR;
            if (typeof Proxy !== "undefined" && Proxy !== null) {
              handler = {
                set: (receiver, key, value) => {
                  if (this[key] != null) {
                    this[key] = value;
                  } else {
                    this.setItem(key, value);
                  }
                  return true;
                },
                get: (receiver, key) => {
                  if (this[key] != null) {
                    return this[key];
                  } else {
                    return this.getItem(key);
                  }
                },
                ownKeys: (target) => {
                  return this._keys.map(function(k) {
                    if (k === KEY_FOR_EMPTY_STRING) {
                      return "";
                    } else {
                      return k;
                    }
                  });
                },
                getOwnPropertyDescriptor: (target, key) => {
                  return {
                    value: this[key],
                    enumerable: true,
                    configurable: true
                  };
                }
              };
              instanceMap[this._location] = new Proxy(this, handler);
              return instanceMap[this._location];
            }
            instanceMap[this._location] = this;
            return instanceMap[this._location];
          }
          _init() {
            var e, stat;
            try {
              stat = fs.statSync(this._location);
              if (stat != null && !stat.isDirectory()) {
                throw new Error(`A file exists at the location '${this._location}' when trying to create/open localStorage`);
              }
              this._sync();
            } catch (error) {
              e = error;
              if (e.code !== "ENOENT") {
                throw e;
              }
              try {
                fs.mkdirSync(this._location, {
                  recursive: true
                });
              } catch (error2) {
                e = error2;
                if (e.code !== "EEXIST") {
                  throw e;
                }
              }
            }
          }
          _sync() {
            var _MetaKey, _decodedKey, _keys, i, index, k, len, stat;
            this._bytesInUse = 0;
            this.length = 0;
            _keys = fs.readdirSync(this._location);
            for (index = i = 0, len = _keys.length; i < len; index = ++i) {
              k = _keys[index];
              _decodedKey = decodeURIComponent(k);
              this._keys.push(_decodedKey);
              _MetaKey = new MetaKey(k, index);
              this._metaKeyMap[_decodedKey] = _MetaKey;
              stat = this._getStat(k);
              if ((stat != null ? stat.size : void 0) != null) {
                _MetaKey.size = stat.size;
                this._bytesInUse += stat.size;
              }
            }
            return this.length = _keys.length;
          }
          setItem(key, value) {
            var encodedKey, evnt, existsBeforeSet, filename, hasListeners, metaKey, oldLength, oldValue, valueString, valueStringLength;
            hasListeners = this.listenerCount("storage");
            oldValue = null;
            if (hasListeners) {
              oldValue = this.getItem(key);
            }
            key = _escapeKey(key);
            encodedKey = encodeURIComponent(key).replace(/[!'()]/g, escape).replace(/\*/g, "%2A");
            filename = path.join(this._location, encodedKey);
            valueString = `${value}`;
            valueStringLength = valueString.length;
            metaKey = this._metaKeyMap[key];
            existsBeforeSet = !!metaKey;
            if (existsBeforeSet) {
              oldLength = metaKey.size;
            } else {
              oldLength = 0;
            }
            if (this._bytesInUse - oldLength + valueStringLength > this.quota) {
              throw new QUOTA_EXCEEDED_ERR();
            }
            writeSync(filename, valueString, {
              encoding: "utf8"
            });
            if (!existsBeforeSet) {
              metaKey = new MetaKey(encodedKey, this._keys.push(key) - 1);
              metaKey.size = valueStringLength;
              this._metaKeyMap[key] = metaKey;
              this.length += 1;
              this._bytesInUse += valueStringLength;
            }
            if (hasListeners) {
              evnt = new StorageEvent(key, oldValue, value, this._eventUrl);
              return this.emit("storage", evnt);
            }
          }
          getItem(key) {
            var filename, metaKey;
            key = _escapeKey(key);
            metaKey = this._metaKeyMap[key];
            if (!!metaKey) {
              filename = path.join(this._location, metaKey.key);
              return fs.readFileSync(filename, "utf8");
            } else {
              return null;
            }
          }
          _getStat(key) {
            var filename;
            key = _escapeKey(key);
            filename = path.join(this._location, encodeURIComponent(key));
            try {
              return fs.statSync(filename);
            } catch (error) {
              return null;
            }
          }
          removeItem(key) {
            var evnt, filename, hasListeners, k, meta, metaKey, oldValue, ref, v;
            key = _escapeKey(key);
            metaKey = this._metaKeyMap[key];
            if (!!metaKey) {
              hasListeners = this.listenerCount("storage");
              oldValue = null;
              if (hasListeners) {
                oldValue = this.getItem(key);
              }
              delete this._metaKeyMap[key];
              this.length -= 1;
              this._bytesInUse -= metaKey.size;
              filename = path.join(this._location, metaKey.key);
              this._keys.splice(metaKey.index, 1);
              ref = this._metaKeyMap;
              for (k in ref) {
                v = ref[k];
                meta = this._metaKeyMap[k];
                if (meta.index > metaKey.index) {
                  meta.index -= 1;
                }
              }
              _rm(filename);
              if (hasListeners) {
                evnt = new StorageEvent(key, oldValue, null, this._eventUrl);
                return this.emit("storage", evnt);
              }
            }
          }
          key(n) {
            var rawKey;
            rawKey = this._keys[n];
            if (rawKey === KEY_FOR_EMPTY_STRING) {
              return "";
            } else {
              return rawKey;
            }
          }
          clear() {
            var evnt;
            _emptyDirectory(this._location);
            this._metaKeyMap = createMap();
            this._keys = [];
            this.length = 0;
            this._bytesInUse = 0;
            if (this.listenerCount("storage")) {
              evnt = new StorageEvent(null, null, null, this._eventUrl);
              return this.emit("storage", evnt);
            }
          }
          _getBytesInUse() {
            return this._bytesInUse;
          }
          _deleteLocation() {
            delete instanceMap[this._location];
            _rm(this._location);
            this._metaKeyMap = {};
            this._keys = [];
            this.length = 0;
            return this._bytesInUse = 0;
          }
        }
        ;
        instanceMap = {};
        return LocalStorage2;
      }).call(this);
      JSONStorage = class JSONStorage extends LocalStorage {
        setItem(key, value) {
          var newValue;
          newValue = JSON.stringify(value);
          return super.setItem(key, newValue);
        }
        getItem(key) {
          return JSON.parse(super.getItem(key));
        }
      };
      exports.LocalStorage = LocalStorage;
      exports.JSONStorage = JSONStorage;
      exports.QUOTA_EXCEEDED_ERR = QUOTA_EXCEEDED_ERR;
    }).call(exports);
  }
});
export default require_LocalStorage();
/*! Bundled license information:

imurmurhash/imurmurhash.js:
  (**
   * @preserve
   * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
   *
   * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
   * @see http://github.com/homebrewing/brauhaus-diff
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *)
*/
//# sourceMappingURL=node-localstorage.js.map
